From fae_gtlc_mu.refinements.static_gradual Require Export logical_relation resources_right compat_easy.
From fae_gtlc_mu.cast_calculus Require Export types typing.
From fae_gtlc_mu.stlc_mu Require Export lang.
From fae_gtlc_mu.cast_calculus Require Export lang.
From iris.algebra Require Import list.
From iris.proofmode Require Import tactics.
From iris.program_logic Require Import lifting.
From fae_gtlc_mu.cast_calculus Require Export types.
From fae_gtlc_mu.cast_calculus Require Export consistency.structural.definition.
From fae_gtlc_mu.backtranslation Require Export cast_help.general cast_help.extract cast_help.embed.

Section extract_embed.
  Context `{!implG Œ£,!specG Œ£}.
  Notation D := (prodO stlc_mu.lang.valO cast_calculus.lang.valO -n> iPropO Œ£).
  (* Implicit Types e : stlc_mu.lang.expr. *)
  (* Implicit Types e : stlc_mu.lang.expr. *)
  Implicit Types fs : list stlc_mu.lang.val.
  (* Implicit Types f : stlc_mu.lang.val. *)
  Implicit Types A : list (cast_calculus.types.type * cast_calculus.types.type).
  (* Implicit Types a : (cast_calculus.types.type * cast_calculus.types.type). *)
  Local Hint Resolve to_of_val : core.

  (** We need to "close up" ùìï pC with functions... *)

 Lemma wp_Œ© Œ¶ : ‚ä¢ (True -‚àó (WP Œ© {{ Œ¶ }}))%I.
 Proof.
   iIntros.
   iL√∂b as "IH".
   iApply wp_pure_step_later; auto; iNext; asimpl.
   iApply (wp_bind $ stlc_mu.lang.fill_item $ stlc_mu.lang.AppLCtx _).
   iApply wp_pure_step_later; auto.
   iNext.
   iApply wp_value.
   fold Œ©. done.
 Qed.


 (* WP extract  *)

 (*  WP extract_TUnit.[stlc_mu.typing.env_subst fs] (# embedV_TUnit w) *)
 (*                                                  1 *)
 (*  extract_TUnit.[stlc_mu.typing.env_subst fs] *)
 (*         (# embedV_Ground_TProd p) *)

 (*  Lemma back_cast_ar_all {A} {œÑi œÑf} (pC : cons_struct A œÑi œÑf) : back_cast_ar pC. *)
 (*  Proof. *)
 (*    induction pC; rewrite /ùìïc /ùìï /back_cast_ar; iIntros (ei' K' v v' fs) "(Hfs & Hvv' & #Hei' & Hv')". *)
 (*    - rewrite /ùìïc /ùìï /extract. *)
 (*      destruct G. *)
 (*      + rewrite interp_unknown_unfold /interp_unknown1; iDestruct "Hvv'" as "#Hvv'"; iDestruct "Hvv'" as "[Hvv'Unit|[Hpp'|[Hss'|[Hff'|Hur']]] ]"; fold interp_unknown1 interp_unknown. *)
 (*        * iDestruct "Hvv'Unit" as ((w , w')) "[% Hww']"; simpl in H; inversion H; clear v v' H H1 H2. *)
 (*          asimpl. *)
 (*          iApply wp_pure_step_later; auto; iNext; asimpl. *)
 (*          iDestruct "Hww'" as "%"; inversion H; rewrite H0 H1; clear w w' H H0 H1. *)
 (*          iApply (wp_bind (stlc_mu.lang.fill_item $ stlc_mu.lang.CaseCtx _ _)). *)
 (*          iApply wp_pure_step_later; auto; iNext. *)
 (*          iApply wp_value. *)
 (*          iApply wp_pure_step_later; auto; iNext. *)
 (*          iApply wp_pure_step_later; auto; iNext. asimpl. *)
 (*          iApply wp_pure_step_later; auto; iNext. *)
 (*          iApply wp_pure_step_later; auto; iNext. asimpl. *)
 (*          iMod (step_pure _ ei' K' (Cast (Cast Unit TUnit ‚ãÜ) ‚ãÜ TUnit) (# UnitV) with "[Hv']") as "HHHH"; intros; auto. *)
 (*          apply Same_Ground with (v := UnitV ); auto; constructor. *)
 (*          iApply wp_value. *)
 (*          iExists UnitV. *)
 (*          by repeat iFrame. *)
 (*        * (* diverging branch *) *)
 (*          iDestruct "Hpp'" as ((p , p')) "[% Hpp']"; simpl in H; inversion H; clear H H1 H2 v v'. *)
 (*          asimpl. *)
 (*          iApply wp_pure_step_later; auto; iNext; asimpl. *)
 (*          iDestruct "Hpp'" as ((v1 , v1') (v2 , v2')) "[% [Hv1v1' Hv2v2']]"; simpl in H; inversion H; clear H H1 H2 p p'. *)
 (*          iApply (wp_bind (stlc_mu.lang.fill_item $ stlc_mu.lang.CaseCtx _ _)). *)
 (*          iApply wp_pure_step_later; auto; iNext. *)
 (*          iApply wp_value. *)
 (*          iApply wp_pure_step_later; auto; iNext; asimpl. *)
 (*          iApply wp_pure_step_later; auto; iNext; asimpl. *)
 (*          iApply wp_pure_step_later; auto; iNext. asimpl. *)
 (*          by iApply wp_Œ©. *)
 (*        * admit. *)
 (*        * admit. *)
 (*        * iDestruct "Hur'" as ((u , r')) "[% Hr]". simpl in H. inversion H. clear H H1 H2. *)
 (*          admit. *)
 (*      + rewrite interp_unknown_unfold /interp_unknown1; iDestruct "Hvv'" as "#Hvv'"; iDestruct "Hvv'" as "[Hvv'Unit|[Hpp'|[Hss'|[Hff'|Hur']]] ]"; fold interp_unknown1 interp_unknown. *)
 (*        * (* diverging branch *) *)
 (*          iDestruct "Hvv'Unit" as ((w , w')) "[% Hww']"; simpl in H; inversion H; clear v v' H H1 H2. *)
 (*          asimpl. *)
 (*          iApply wp_pure_step_later; auto; iNext; asimpl. *)
 (*          iDestruct "Hww'" as "%"; inversion H; rewrite H0 H1; clear w w' H H0 H1. *)
 (*          iApply (wp_bind (stlc_mu.lang.fill_item $ stlc_mu.lang.CaseCtx _ _)). *)
 (*          iApply wp_pure_step_later; auto; iNext. *)
 (*          iApply wp_value. *)
 (*          iApply (wp_bind (stlc_mu.lang.fill_item $ stlc_mu.lang.CaseCtx _ _)). *)
 (*          iApply wp_value. *)
 (*          iApply wp_pure_step_later; auto; iNext. *)
 (*          iApply wp_pure_step_later; auto; iNext. asimpl. *)
 (*          iApply wp_pure_step_later; auto; iNext. asimpl. *)
 (*          by iApply wp_Œ©. *)
 (*        * iDestruct "Hpp'" as ((p , p')) "[% Hpp']"; simpl in H; inversion H; clear H H1 H2. *)
 (*          asimpl. *)
 (*          iApply wp_pure_step_later; auto; iNext; asimpl. *)
 (*          iDestruct "Hpp'" as ((v1 , v1') (v2 , v2')) "[% [Hv1v1' Hv2v2']]"; simpl in H; inversion H; clear H H1 H2 p p'. *)
 (*          iApply (wp_bind (stlc_mu.lang.fill_item $ stlc_mu.lang.CaseCtx _ _)). *)
 (*          iApply wp_pure_step_later; auto; iNext. *)
 (*          iApply wp_value. *)
 (*          iApply wp_pure_step_later; auto; iNext; asimpl. *)
 (*          iApply wp_pure_step_later; auto; iNext; asimpl. *)
 (*          iApply wp_pure_step_later; auto; iNext. asimpl. *)
 (*          iMod (step_pure _ ei' K' *)
 (*                          (Cast *)
 (*                             (Cast (Pair (# v1') (# v2')) *)
 (*                                   (‚ãÜ √ó ‚ãÜ) ‚ãÜ) ‚ãÜ *)
 (*                             (‚ãÜ √ó ‚ãÜ) *)
 (*                          ) *)
 (*                          (Pair (# v1') (# v2')) *)
 (*                  with "[Hv']") as "HHHH"; auto. *)
 (*          intro. eapply Same_Ground. simplify_option_eq. auto. constructor. *)
 (*          iApply wp_value. *)
 (*          iExists (PairV (v1') (v2')). *)
 (*          simpl. repeat iFrame. *)
 (*          iExists (v1 , v1') , (v2 , v2'). by auto. *)
 (*        * admit. *)
 (*        * admit. *)
 (*        * admit. *)
 (*      + admit. *)
 (*      + admit. *)
 (*      + rewrite interp_unknown_unfold /interp_unknown1; iDestruct "Hvv'" as "#Hvv'"; iDestruct "Hvv'" as "[Hvv'Unit|[Hpp'|[Hss'|[Hff'|Hur']]] ]"; fold interp_unknown1 interp_unknown. *)
 (*        * admit. *)
 (*        * admit. *)
 (*        * admit. *)
 (*        * admit. *)
 (*        * iDestruct "Hur'" as ((u , r')) "[% Hur']"; inversion H; clear H H1 H2. *)
 (*          iMod (step_pure _ ei' K' *)
 (*                          (Cast (# castupV_TRec r') ‚ãÜ (TRec ‚ãÜ)) *)
 (*                          (# r') *)
 (*                  with "[Hv']") as "HHHH"; auto. *)
 (*          intro; eapply Same_Ground; simplify_option_eq; auto; constructor. *)
 (*          iApply wp_pure_step_later; auto; iNext; asimpl. *)
 (*          iApply (wp_bind (stlc_mu.lang.fill_item $ stlc_mu.lang.CaseCtx _ _)). *)
 (*          iApply wp_pure_step_later; auto. *)
 (*          iApply wp_value. simpl.  *)
 (*          iApply wp_pure_step_later; auto. asimpl.  *)
 (*          iApply wp_value. *)
 (*          repeat iNext. *)
 (*          iExists r'. by iFrame. *)
 (*    - destruct G; rewrite /ùìïc /ùìï. *)
 (*      + iApply wp_pure_step_later; auto; iNext; asimpl. *)
 (*        iDestruct "Hvv'" as "%"; inversion H. rewrite H0 H1. clear H H0 H1 v v'. *)
 (*        iApply wp_value. iExists (CastV UnitV TUnit ‚ãÜ (From_ground_to_unknown TUnit Ground_TUnit)). *)
 (*        simpl in *. *)
 (*        iFrame. *)
 (*        rewrite interp_unknown_unfold /interp_unknown1. *)
 (*        admit. *)
 (*      + admit. *)
 (*      + admit. *)
 (*      + admit. *)
 (*      + rewrite fixpoint_interp_rec1_eq. *)
 (*        iDestruct "Hvv'" as ((r , r')) "[% #Hrr']". inversion H; clear H H1 H2. *)
 (*        iApply wp_pure_step_later; auto; iNext; asimpl. *)
 (*        iApply (wp_bind (fill [stlc_mu.lang.InjRCtx ; stlc_mu.lang.FoldCtx ])). *)
 (*        iApply wp_pure_step_later; auto. iNext; asimpl. *)
 (*        iApply wp_value. *)
 (*        iApply wp_value. *)
 (*        iExists (CastV (FoldV r') (TRec ‚ãÜ) ‚ãÜ (From_ground_to_unknown (TRec ‚ãÜ) Ground_TRec)). *)
 (*        simpl in *. *)
 (*        iFrame. *)
 (*        rewrite{1} interp_unknown_unfold. *)
 (*        rewrite{1} interp_unknown_unfold. *)
 (*        repeat rewrite{1} /interp_unknown1. *)
 (*        iRight. *)
 (*        iRight. *)
 (*        iRight. *)
 (*        iRight. *)
 (*        iModIntro. *)
 (*        iExists (r , FoldV r'). simpl. iSplitL. *)
 (*        auto. *)
 (*        admit. *)
 (*    - admit. *)
 (*    - admit. *)
 (*    - rewrite /ùìïc /ùìï. asimpl. *)
 (*      iApply wp_pure_step_later; auto. *)
 (*      asimpl. *)
 (*      iDestruct "Hvv'" as %[eq1 eq2]; simplify_eq. *)
 (*      iNext. *)
 (*      iMod (step_pure _ ei' K' (Cast (# UnitV) TUnit TUnit) (# UnitV) with "[Hv']") as "HHHH"; auto. *)
 (*      intros; by eapply IdBase. *)
 (*      iApply wp_value. *)
 (*      iExists UnitV. iFrame. iSplit; trivial. *)
 (*    - rewrite /ùìïc /ùìï; asimpl. *)
 (*      iMod (step_pure _ ei' K' (Cast (# v') ‚ãÜ ‚ãÜ) (# v') with "[Hv']") as "Hv'"; auto. *)
 (*      intros; by eapply IdStar. *)
 (*      iApply wp_pure_step_later; auto; asimpl. *)
 (*      iNext. *)
 (*      iApply wp_value. *)
 (*      iExists v'. iFrame. *)
 (*    - iDestruct "Hvv'" as "[Hvv'1 | Hvv'2]". *)
 (*      + iDestruct "Hvv'1" as (vv'1) "Hvv'1". destruct vv'1 as (v1 , v1'). *)
 (*        iDestruct "Hvv'1" as "[% Hvv'1]". inversion H. *)
 (*        iMod (step_pure _ ei' K' (Cast (# InjLV v1') (œÑ1 + œÑ2)%type (œÑ1' + œÑ2')%type) _ with "[Hv']") as "Hv'"; auto; try (intros; eapply SumCast; auto). *)
 (*        iMod ((step_case_inl _ ei' K' (# v1')) with "[Hv']") as "Hv'"; auto. *)
 (*        (* rewrite /ùìïc /ùìï /between_TSum. *) *)
 (*        rewrite /ùìïc /ùìï. *)
 (*        iApply wp_pure_step_later. auto; asimpl. *)
 (*        iApply wp_pure_step_later; auto; asimpl. *)
 (*        iNext. iNext. *)
 (*        iApply wp_bind. admit. *)
 (*        iApply wp_wand_r. *)
 (*        iSplitL. *)
 (*        iApply (IHpC1 ei' (InjLCtx :: K')). repeat iFrame. auto. *)
 (*        clear H H1 H2 v1 v1'. *)
 (*        iIntros (v1) "HHH". iDestruct "HHH" as (v1') "[Hv1' Hvv'1]". *)
 (*        iApply wp_value. *)
 (*        iExists (InjLV v1'). repeat iFrame. iLeft. iExists (v1 , v1'). *)
 (*        iSplitR. by simpl. done. *)
 (*      + admit. *)
 (*    - iSimpl in "Hvv'". iDestruct "Hvv'" as ((v1 , v1') (v2 , v2')) "[% [Hv1v1' Hv2v2']]". simpl in H; inversion H; clear H H1 H2 v v'. *)
 (*      iApply wp_pure_step_later; auto. *)
 (*      fold (ùìï pC1) (ùìï pC2). asimpl. fold (ùìïc pC1 fs) (ùìïc pC2 fs). *)
 (*      iDestruct "Hfs" as "[% Hfs']"; iAssert (rel_cast_functions A fs) with "[Hfs']" as "Hfs". iSplit; done. *)
 (*      rewrite ùìïc_rewrite. *)
 (*      iApply (wp_bind (fill [stlc_mu.lang.AppRCtx (ùìïcV pC1 fs H) ; stlc_mu.lang.PairLCtx ((ùìïc pC2 fs) (stlc_mu.lang.Snd (stlc_mu.lang.Pair (stlc_mu.lang.of_val v1) (stlc_mu.lang.of_val v2)))) ])). *)
 (*      iApply wp_pure_step_later; auto. *)
 (*      do 2 iNext. iApply wp_value. simpl. *)
 (*      iApply (wp_bind (fill [stlc_mu.lang.PairLCtx ((ùìïc pC2 fs) (stlc_mu.lang.Snd (stlc_mu.lang.Pair (stlc_mu.lang.of_val v1) (stlc_mu.lang.of_val v2)))) ])). *)
 (*      rewrite -ùìïc_rewrite. *)
 (*      iApply (wp_wand with "[Hfs Hv1v1' Hei' Hv']"). *)
 (*      (* iApply (IHpC1 ei' :: K' with "Hfs Hv1v1' Hei' Hv'"). *) *)
 (*      admit. *)
 (*      admit. *)
 (*    - admit. *)
 (*    - rewrite /ùìïc /ùìï. *)
 (*      fold (ùìï pC). *)
 (*      iApply wp_pure_step_later; auto; asimpl. *)
 (*      iApply (wp_bind $ stlc_mu.lang.fill_item $ stlc_mu.lang.AppLCtx _). *)
 (*      iApply wp_pure_step_later; auto; asimpl. *)
 (*      iApply wp_pure_step_later; auto; asimpl. *)

 (*    - rewrite /ùìïc /ùìï. asimpl. *)
 (*      destruct (fs !! i) as [f | abs] eqn:Hf. *)
 (*      + rewrite (stlc_mu.typing.env_subst_lookup _ _ f); auto. *)
 (*        iDestruct "Hfs" as "[% Hfs]". *)
 (*        rewrite fixpoint_interp_rec1_eq. *)
        
 (*        rewrite interp_unknown_unfold /interp_unknown1. *)
 (*        unfold fixpoint_re *)
 (*        iAssert  *)
        
 (*    destruct () *)


End extract_embed.
