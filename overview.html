<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
    <title>An overview of the Coq Formalization</title>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <link href="html/coqdoc.css" rel="stylesheet" type="text/css" />
    <link href="html/coqdocjs.css" rel="stylesheet" type="text/css"/>
</head>

<body onload="document.getElementById('content').focus()">
  <div id="header">
    <span class="left">
      <span class="modulename"> <script> document.write(document.title) </script> </span>
    </span>

    <span class="button" id="toggle-proofs"></span>

    <span class="right">
      <a href="">Project Page</a>
      <a href="html/indexpage.html"> Index </a>
      <a href="html/toc.html"> Table of Contents </a>
    </span>
</div>
    <div id="content" tabindex="-1" onblur="document.getElementById('content').focus()">
    <div id="main">

    <h1>An overview of the Coq Formalization</h1>
    <h4 style="margin-left:1em">For the Coq code, click on the file name of each part of the development.</h4>
    <p>This repo contains a Coq/Iris proof of the fact that the embedding of STLCmu (the simply typed lambda calculus with equirecursive types) into GTLCmu (its gradualization) is fully abstract. It accompanies the paper “Fully abstract from Static to Gradual”.</p>
    
    <h2 id="verifying-the-full-abstraction-claim">Verifying the full abstraction claim</h2>
    <p>This section describes the files necessary to go through in order to verify that full abstraction is indeed proven for the embedding from STLCmu to GTLCmu.</p>
    <h3 id="verifying-definition-of-the-simply-typed-lambda-calculus-with-iso-recursive-types">Verifying definition of the simply typed lambda calculus with iso-recursive types</h3>
    <ul>
        <li><a href="html/fae_gtlc_mu.stlc_mu.lang.html" class="uri">theories/stlc_mu/lang.v</a> starts by defining the expressions and values; for this we use De Bruijn indices, utilizing <a href="https://www.ps.uni-saarland.de/autosubst/doc/manual.pdf">Autosubst</a> to do so (detailed knowledge is not required). Afterwards, it defines evaluation contexts (of depth 1) and head step reductions. The final language is defined using the <code>EctxiLanguage</code> construct from the Iris library; essentially, it naturally defines the general evaluation contexts and the total reduction relation. Lastly, we define the <code>Halts</code> predicative for expressions.</li>
        <li><a href="html/fae_gtlc_mu.stlc_mu.types.html" class="uri">theories/stlc_mu/types.v</a> defines the static types (again using Autosubst).</li>
        <li><a href="html/fae_gtlc_mu.stlc_mu.typing.html" class="uri">theories/stlc_mu/typing.v</a> defines the typing rules for expressions. We restrict our typing derivations so that they only treat meaningful types; the closed types (types with no free variables) (see <a href="html/fae_gtlc_mu.prelude.html" class="uri">theories/prelude.v</a> for the formal definition of closedness).</li>
        <li><a href="html/fae_gtlc_mu.stlc_mu.contexts.html" class="uri">theories/stlc_mu/contexts.v</a> defines general contexts (not evaluation contexts) together with their typing rules.</li>
        <li><a href="html/fae_gtlc_mu.stlc_mu.ctx_equiv.html" class="uri">theories/stlc_mu/ctx_equiv.v</a> defines contextual equivalence.</li>
    </ul>
    <h3 id="verifying-definition-of-the-cast-calculus-of-gtlcmu">Verifying definition of the cast calculus of GTLCmu</h3>
    <ul>
        <li><a href="html/fae_gtlc_mu.cast_calculus.types.html" class="uri">theories/cast_calculus/types.v</a> defines the gradual types, ground types, the shape operator (S in figure 2 of paper) and type <code>ICP</code> to encode inert pairs (two function types or a ground and unknown type) which is used in <a href="html/fae_gtlc_mu.cast_calculus.lang.html" class="uri">theories/cast_calculus/lang.v</a> to define which expressions are values.</li>
        <li><a href="html/fae_gtlc_mu.cast_calculus.types_notations.html" class="uri">theories/cast_calculus/types_notations.v</a> defines some handy notations for types.</li>
        <li><a href="html/fae_gtlc_mu.cast_calculus.lang.html" class="uri">theories/cast_calculus/lang.v</a> defines expressions, values, evaluation contexts, head reductions, total reduction, and a <code>Halts</code> predicate on expressions.</li>
        <li><a href="html/fae_gtlc_mu.cast_calculus.consistency.html" class="uri">theories/cast_calculus/consistency.v</a> defines the conventional consistency relation (figure 1 in paper)</li>
        <li><a href="html/fae_gtlc_mu.cast_calculus.typing.html" class="uri">theories/cast_calculus/typing.v</a> defines the typing rules for expressions. We restrict our typing derivations so that they only treat meaningful types; the closed types (types with no free variables) (see [theories/prelude.v] for the formal definition of closedness).</li>
        <li><a href="html/fae_gtlc_mu.cast_calculus.contexts.html" class="uri">theories/cast_calculus/contexts.v</a> defines general contexts (not evaluation contexts) together with their typing rules.</li>
        <li><a href="html/fae_gtlc_mu.cast_calculus.ctx_equiv.html" class="uri">theories/cast_calculus/ctx_equiv.v</a> defines contextual equivalence.</li>
    </ul>
    <h3 id="verifying-the-embedding-from-stlcmu-into-the-cast-calculus">Verifying the embedding from STLCmu into the cast calculus</h3>
    <ul>
        <li><a href="html/fae_gtlc_mu.embedding.expressions.html" class="uri">theories/embedding/expressions.v</a> defines the embedding on expressions</li>
        <li><a href="html/fae_gtlc_mu.embedding.contexts.html" class="uri">theories/embedding/contexts.v</a> defines the embedding on contexts</li>
        <li><a href="html/fae_gtlc_mu.embedding.types.html" class="uri">theories/embedding/types.v</a> defines the embedding on types</li>
        <li><a href="html/fae_gtlc_mu.embedding.well_typedness.html" class="uri">theories/embedding/well_typedness.v</a> proves the preservation of well-typedness after embedding</li>
    </ul>
    <h3 id="verifying-full-abstraction-claim">Verifying full abstraction claim</h3>
    <p>The file <a href="html/fae_gtlc_mu.fae.html" class="uri">theories/fae.v</a> proves full abstraction of the embedding. Theorem <code>ctx_eq_preservation</code> proves preservation of equivalences, and <code>ctx_eq_reflection</code> proves reflection of equivalences.</p>
    <h2 id="proof-structure-wheres-what">Proof structure (where’s what?)</h2>
    <p>Cool, so you’re actually interested in the proof itself! This section describes some of the more interesting files that make up the proof, referring to the paper where possible; for a complete listing of all files, one can refer to the commented <a href="_CoqProject" class="uri">_CoqProject</a> file.</p>
    <h3 id="defining-backtranslation-section-4.2-in-paper">Defining backtranslation (section 4.2 in paper)</h3>
    <ul>
        <li><a href="html/fae_gtlc_mu.backtranslation.alternative_consistency.html" class="uri">theories/backtranslation/alternative_consistency.v</a> defines the alternative consistency relation as in figure 9 of paper</li>
        <li><a href="html/fae_gtlc_mu.backtranslation.implication_consistencies.proof.html" class="uri">theories/backtranslation/implication_consistencies/proof.v</a> proves that the conventional relations implies the alternative one, as is claimed in the “Is this Well-Defined”-paragraph</li>
        <li><a href="html/fae_gtlc_mu.backtranslation.cast_help.universe.html" class="uri">theories/backtranslation/cast_help/universe.v</a> defines the universe (equation 1 in paper)</li>
        <li><a href="html/fae_gtlc_mu.backtranslation.types.html" class="uri">theories/backtranslation/types.v</a> defines the backtranslation on types (figure 6 and equation 1 in paper)</li>
        <li><a href="html/fae_gtlc_mu.backtranslation.cast_help.embed.html" class="uri">theories/backtranslation/cast_help/embed.v</a> defines backtranslation of casts from ground to unknown (figure 7 in paper)</li>
        <li><a href="html/fae_gtlc_mu.backtranslation.cast_help.extract.html" class="uri">theories/backtranslation/cast_help/extract.v</a> defines backtranslation of casts from unknown to ground (figure 7 in paper)</li>
        <li><a href="html/fae_gtlc_mu.backtranslation.cast_help.extract.html" class="uri">theories/backtranslation/cast_help/extract.v</a> defines backtranslation of casts from unknown to ground (figure 7 in paper)</li>
        <li><a href="html/fae_gtlc_mu.backtranslation.cast_help.factorize.html" class="uri">theories/backtranslation/cast_help/factorize.v</a>: factorizing upcasts and downcasts (figure 9)</li>
        <li><a href="html/fae_gtlc_mu.backtranslation.cast_help.between.html" class="uri">theories/backtranslation/cast_help/between.v</a>: casts between sum, product, recursive and arrow types</li>
        <li><p><a href="html/fae_gtlc_mu.backtranslation.cast_help.general_def.html" class="uri">theories/backtranslation/cast_help/general_def.v</a> brings it all together (figure 9)</p></li>
        <li><a href="html/fae_gtlc_mu.backtranslation.expressions.html" class="uri">theories/backtranslation/expressions.v</a>: actual backtranslation on terms</li>
        <li><a href="html/fae_gtlc_mu.backtranslation.contexts.html" class="uri">theories/backtranslation/contexts.v</a>: on contexts</li>
        <li><p><a href="html/fae_gtlc_mu.backtranslation.well_typedness.html" class="uri">theories/backtranslation/well_typedness.v</a>: proves well-typedness of backtranslation</p></li>
    </ul>
    <h3 id="defining-logical-relations-from-static-to-gradual-section-4.3.3">Defining logical relations from static to gradual (section 4.3.3)</h3>
    <ul>
        <li><a href="html/fae_gtlc_mu.refinements.static_gradual.resources_left.html" class="uri">theories/refinements/static_gradual/resources_left.v</a>: setting up Iris resources for static side</li>
        <li><a href="html/fae_gtlc_mu.refinements.static_gradual.resources_right.html" class="uri">theories/refinements/static_gradual/resources_right.v</a>: setting up Iris resources for gradual side</li>
        <li><a href="html/fae_gtlc_mu.refinements.static_gradual.logical_relation.html" class="uri">theories/refinements/static_gradual/logical_relation.v</a>: defining logical relations (section 4.3.3 in paper)</li>
    </ul>
    <h3 id="proving-specification-for-lr-from-static-to-gradual-section-4.3.2-and-4.3.4">Proving specification for LR from static to gradual (section 4.3.2 and 4.3.4)</h3>
    <ul>
        <li><a href="html/fae_gtlc_mu.refinements.static_gradual.compat_easy.html" class="uri">theories/refinements/static_gradual/compat_easy.v</a> proves the unexciting lemmas (fig 12 in the paper)</li>
        <li><a href="html/fae_gtlc_mu.refinements.static_gradual.compat_cast.defs.html" class="uri">theories/refinements/static_gradual/compat_cast/defs.v</a> defines the generalized compatibility lemma for casts (lemma 4.7)</li>
        <li><a href="html/fae_gtlc_mu.refinements.static_gradual.compat_cast.all.html" class="uri">theories/refinements/static_gradual/compat_cast/all.v</a> proves the compatibility lemma on casts; it brings together the different cases defined in the same folder</li>
        <li>[theories/refinements/static_gradual/rel_ref_specs.v][theories/refinements/static_gradual/rel_ref_specs.v] proves that gradual contexts are related to their backtranslation and that static terms are related to their embeddings (lemma 4.2 in paper)</li>
        <li><a href="html/fae_gtlc_mu.refinements.static_gradual.adequacy.html" class="uri">theories/refinements/static_gradual/adequacy.v</a> proves adequacy of logical relations (lemma 4.3)</li>
    </ul>
    <h3 id="defining-logical-relations-from-gradual-to-static-mostly-analogous-and-not-in-the-paper">Defining logical relations from gradual to static (mostly analogous and not in the paper)</h3>
    <ul>
        <li><a href="html/fae_gtlc_mu.refinements.gradual_static.resources_left.html" class="uri">theories/refinements/gradual_static/resources_left.v</a>: setting up Iris resources for gradual side</li>
        <li><a href="html/fae_gtlc_mu.refinements.gradual_static.resources_right.html" class="uri">theories/refinements/gradual_static/resources_right.v</a>: setting up Iris resources for static side</li>
        <li><a href="html/fae_gtlc_mu.refinements.gradual_static.logical_relation.html" class="uri">theories/refinements/gradual_static/logical_relation.v</a> defining logical relations</li>
    </ul>
    <h3 id="proving-specification-for-lr-from-gradual-to-static-mostly-analogous-and-mostly-absent-in-paper">Proving specification for LR from gradual to static (mostly analogous and mostly absent in paper)</h3>
    <ul>
        <li><a href="html/fae_gtlc_mu.refinements.gradual_static.compat_easy.html" class="uri">theories/refinements/gradual_static/compat_easy.v</a> proves the unexciting lemmas (not in paper)</li>
        <li><a href="html/fae_gtlc_mu.refinements.gradual_static.compat_cast.defs.html" class="uri">theories/refinements/gradual_static/compat_cast/defs.v</a> defines the generalized compatibility lemma for casts (not in paper)</li>
        <li><a href="html/fae_gtlc_mu.refinements.gradual_static.compat_cast.all.html" class="uri">theories/refinements/gradual_static/compat_cast/all.v</a> proves the compatibility lemma on casts; it brings together the different cases defined in the same folder</li>
        <li>[theories/refinements/gradual_static/rel_ref_specs.v][theories/refinements/gradual_static/rel_ref_specs.v] proves that static contexts are related to their backtranslation and that gradual terms are related to their embeddings (lemma 4.4 in paper)</li>
        <li><a href="html/fae_gtlc_mu.refinements.gradual_static.adequacy.html">theories/refinements/gradual_static/adequacy.v</a> proves adequacy of logical relations (lemma 4.5)</li>
    </ul>
    <h3 id="bringing-stuff-together-in-theoriesfae.v">Bringing stuff together in <a href="html/fae_gtlc_mu.fae.html" class="uri">theories/fae.v</a></h3>
    <p>Both directions of theorem 4.1 from the paper are proven there.</p>

    </body>
</html>
