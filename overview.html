<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
    <title>An overview of the Coq Formalization</title>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <link href="html/coqdoc.css" rel="stylesheet" type="text/css" />
    <link href="html/coqdocjs.css" rel="stylesheet" type="text/css"/>
</head>

<body onload="document.getElementById('content').focus()">
  <div id="header">
    <span class="left">
      <span class="modulename"> <script> document.write(document.title) </script> </span>
    </span>

    <span class="button" id="toggle-proofs"></span>

    <span class="right">
      <a href="">Project Page</a>
      <a href="html/indexpage.html"> Index </a>
      <a href="html/toc.html"> Table of Contents </a>
    </span>
</div>
    <div id="content" tabindex="-1" onblur="document.getElementById('content').focus()">
    <div id="main">
    <h1>An overview of the Coq Formalization</h1>
    <h4 style="margin-left:1em">For the Coq code, click on the file name of each part of the development.</h4>
<h2 id="verifying-the-full-abstraction-claim">Verifying the full abstraction claim</h2>
<p>This section describes the files necessary to go through in order to verify that full abstraction is indeed proven for the embedding from STLCmu to GTLCmu.</p>
<h3 id="verifying-definition-of-the-simply-typed-lambda-calculus-with-iso-recursive-types">Verifying definition of the simply typed lambda calculus with iso-recursive types</h3>
<ul>
<li><a href="theories/stlc_mu/lang.v" class="uri">theories/stlc_mu/lang.v</a> starts by defining the expressions and values; for this we use De Bruijn indices, utilizing <a href="Autosubst">https://www.ps.uni-saarland.de/autosubst/doc/manual.pdf</a> to do so (detailed knowledge is not required). Afterwards, it defines evaluation contexts (of depth 1) and head step reductions. The final language is defined using the <code>EctxiLanguage</code> construct from the Iris library; essentially, it naturally defines the general evaluation contexts and the total reduction relation. Lastly, we define the <code>Halts</code> predicative for expressions.</li>
<li><a href="theories/stlc_mu/types.v" class="uri">theories/stlc_mu/types.v</a> defines the static types (again using Autosubst).</li>
<li><a href="theories/stlc_mu/typing.v" class="uri">theories/stlc_mu/typing.v</a> defines the typing rules for expressions. We restrict our typing derivations so that they only treat meaningful types; the closed types (types with no free variables) (see [theories/prelude.v] for the formal definition of closedness).</li>
<li><a href="theories/stlc_mu/contexts.v" class="uri">theories/stlc_mu/contexts.v</a> defines general contexts (not evaluation contexts) together with their typing rules.</li>
<li><a href="theories/stlc_mu/ctx_equiv.v" class="uri">theories/stlc_mu/ctx_equiv.v</a> defines contextual equivalence.</li>
</ul>
<h3 id="verifying-definition-of-the-cast-calculus-of-gtlcmu">Verifying definition of the cast calculus of GTLCmu</h3>
<ul>
<li><a href="theories/cast_calculus/types.v" class="uri">theories/cast_calculus/types.v</a> defines the gradual types, ground types, the shape operator (S in figure 2 of paper) and type <code>ICP</code> to encode inert pairs (two function types or a ground and unknown type) which is used in <a href="lang.v">theories/cast_calculus/lang.v</a> to define which expressions are values.</li>
<li>[theories/cast_calculus/types_notations.v] defines some handy notations for types.</li>
<li><a href="theories/cast_calculus/lang.v" class="uri">theories/cast_calculus/lang.v</a> defines expressions, values, evaluation contexts, head reductions, total reduction, and a <code>Halts</code> predicate on expressions.</li>
<li><a href="theories/cast_calculus/consistency.v" class="uri">theories/cast_calculus/consistency.v</a> defines the conventional consistency relation (figure 1 in paper)</li>
<li><a href="theories/cast_calculus/typing.v" class="uri">theories/cast_calculus/typing.v</a> defines the typing rules for expressions. We restrict our typing derivations so that they only treat meaningful types; the closed types (types with no free variables) (see [theories/prelude.v] for the formal definition of closedness).</li>
<li><a href="theories/cast_calculus/contexts.v" class="uri">theories/cast_calculus/contexts.v</a> defines general contexts (not evaluation contexts) together with their typing rules.</li>
<li><a href="theories/cast_calculus/ctx_equiv.v" class="uri">theories/cast_calculus/ctx_equiv.v</a> Defines contextual equivalence.</li>
</ul>
<h3 id="verifying-the-embedding-from-stlcmu-into-the-cast-calculus">Verifying the embedding from STLCmu into the cast calculus</h3>
<ul>
<li><a href="theories/embedding/expressions.v" class="uri">theories/embedding/expressions.v</a> defines the embedding on expressions</li>
<li><a href="theories/embedding/contexts.v" class="uri">theories/embedding/contexts.v</a> defines the embedding on contexts</li>
<li><a href="theories/embedding/types.v" class="uri">theories/embedding/types.v</a> defines the embedding on types</li>
<li><a href="theories/embedding/well_typedness.v" class="uri">theories/embedding/well_typedness.v</a> proves the preservation of well-typedness after embedding</li>
</ul>
<h3 id="verifying-full-abstraction-claim">Verifying full abstraction claim</h3>
<p>The file <a href="theories/fae.v" class="uri">theories/fae.v</a> proves full abstraction of the embedding. Theorem <code>ctx_eq_preservation</code> proves preservation of equivalences, and <code>ctx_eq_reflection</code> proves reflection of equivalences.</p>
<h2 id="proof-structure-wheres-what">Proof structure (where’s what?)</h2>
<p>Cool, so you’re actually interested in the proof itself! This section describes some of the more interesting files that make up the proof, referring to the text where possible; for a complete listing of all files, one can refer to the commented <a href="_CoqProject" class="uri">_CoqProject</a> file.</p>
<h3 id="defining-backtranslation-section-4.2-in-paper">Defining backtranslation (section 4.2 in paper)</h3>
<ul>
<li><a href="theories/backtranslation/alternative_consistency.v" class="uri">theories/backtranslation/alternative_consistency.v</a> defines the alternative consistency relation as in figure 9 of paper</li>
<li><a href="theories/backtranslation/implication_consistencies/proof.v" class="uri">theories/backtranslation/implication_consistencies/proof.v</a> proves that the conventional relations implies the alternative one, as is claimed in the “Is this Well-Defined”-paragraph</li>
<li><a href="theories/backtranslation/cast_help/universe.v" class="uri">theories/backtranslation/cast_help/universe.v</a> defines the universe (equation 1 in paper)</li>
<li><a href="theories/backtranslation/types.v" class="uri">theories/backtranslation/types.v</a> defines the backtranslation on types (figure 6 and equation 1 in paper)</li>
<li><a href="theories/backtranslation/cast_help/embed.v" class="uri">theories/backtranslation/cast_help/embed.v</a> defines backtranslation of casts from ground to unknown (figure 7 in paper)</li>
<li><a href="theories/backtranslation/cast_help/extract.v" class="uri">theories/backtranslation/cast_help/extract.v</a> defines backtranslation of casts from unknown to ground (figure 7 in paper)</li>
<li><a href="theories/backtranslation/cast_help/extract.v" class="uri">theories/backtranslation/cast_help/extract.v</a> defines backtranslation of casts from unknown to ground (figure 7 in paper)</li>
<li><a href="theories/backtranslation/cast_help/factorize.v" class="uri">theories/backtranslation/cast_help/factorize.v</a>: factorizing upcasts and downcasts (figure 9)</li>
<li><a href="theories/backtranslation/cast_help/between.v" class="uri">theories/backtranslation/cast_help/between.v</a>: casts between sum, product, recursive and arrow types</li>
<li><p><a href="theories/backtranslation/cast_help/general_def.v" class="uri">theories/backtranslation/cast_help/general_def.v</a> brings it all together (figure 9)</p></li>
<li><a href="theories/backtranslation/expressions.v" class="uri">theories/backtranslation/expressions.v</a>: actual backtranslation on terms</li>
<li><a href="theories/backtranslation/contexts.v" class="uri">theories/backtranslation/contexts.v</a>: on contexts</li>
<li><p><a href="theories/backtranslation/well_typedness.v" class="uri">theories/backtranslation/well_typedness.v</a>: proves well-typedness of backtranslation</p></li>
</ul>
<h3 id="defining-logical-relations-from-static-to-gradual-section-4.3.3">Defining logical relations from static to gradual (section 4.3.3)</h3>
<ul>
<li><a href="theories/refinements/static_gradual/resources_left.v" class="uri">theories/refinements/static_gradual/resources_left.v</a>: setting up Iris resources for static side</li>
<li><a href="theories/refinements/static_gradual/resources_right.v" class="uri">theories/refinements/static_gradual/resources_right.v</a>: setting up Iris resources for gradual side</li>
<li><a href="theories/refinements/static_gradual/logical_relation.v" class="uri">theories/refinements/static_gradual/logical_relation.v</a>: defining logical relations (section 4.3.3 in paper)</li>
</ul>
<h3 id="proving-specification-for-lr-from-static-to-gradual-section-4.3.2-and-4.3.4">Proving specification for LR from static to gradual (section 4.3.2 and 4.3.4)</h3>
<ul>
<li><a href="theories/refinements/static_gradual/compat_easy.v" class="uri">theories/refinements/static_gradual/compat_easy.v</a> proves the unexciting lemmas (fig 12 in the paper)</li>
<li><a href="theories/refinements/static_gradual/compat_cast/defs.v" class="uri">theories/refinements/static_gradual/compat_cast/defs.v</a> defines the generalized compatibility lemma for casts (lemma 4.7)</li>
<li><a href="theories/refinements/static_gradual/compat_cast/all.v" class="uri">theories/refinements/static_gradual/compat_cast/all.v</a> proves the compatibility lemma on casts; it brings together the different cases defined in the same folder</li>
<li>[theories/refinements/static_gradual/rel_ref_specs.v][theories/refinements/static_gradual/rel_ref_specs.v] proves that gradual contexts are related to their backtranslation and that static terms are related to their embeddings (lemma 4.2 in paper)</li>
<li><a href="theories/refinements/static_gradual/adequacy.v" class="uri">theories/refinements/static_gradual/adequacy.v</a> proves adequacy of logical relations (lemma 4.3)</li>
</ul>
<h3 id="defining-logical-relations-from-gradual-to-static-mostly-analogous-and-not-in-the-paper">Defining logical relations from gradual to static (mostly analogous and not in the paper)</h3>
<ul>
<li><a href="theories/refinements/gradual_static/resources_left.v" class="uri">theories/refinements/gradual_static/resources_left.v</a>: setting up Iris resources for gradual side</li>
<li><a href="theories/refinements/gradual_static/resources_right.v" class="uri">theories/refinements/gradual_static/resources_right.v</a>: setting up Iris resources for static side</li>
<li><a href="theories/refinements/gradual_static/logical_relation.v" class="uri">theories/refinements/gradual_static/logical_relation.v</a> defining logical relations</li>
</ul>
<h3 id="proving-specification-for-lr-from-gradual-to-static-mostly-analogous-and-mostly-absent-in-paper">Proving specification for LR from gradual to static (mostly analogous and mostly absent in paper)</h3>
<ul>
<li><a href="theories/refinements/gradual_static/compat_easy.v" class="uri">theories/refinements/gradual_static/compat_easy.v</a> proves the unexciting lemmas (not in paper)</li>
<li><a href="theories/refinements/gradual_static/compat_cast/defs.v" class="uri">theories/refinements/gradual_static/compat_cast/defs.v</a> defines the generalized compatibility lemma for casts (not in paper)</li>
<li><a href="theories/refinements/gradual_static/compat_cast/all.v" class="uri">theories/refinements/gradual_static/compat_cast/all.v</a> proves the compatibility lemma on casts; it brings together the different cases defined in the same folder</li>
<li>[theories/refinements/gradual_static/rel_ref_specs.v][theories/refinements/gradual_static/rel_ref_specs.v] proves that static contexts are related to their backtranslation and that gradual terms are related to their embeddings (lemma 4.4 in paper)</li>
<li><a href="theories/refinements/static_static/adequacy.v">theories/refinements/gradual_static/adequacy.v</a> proves adequacy of logical relations (lemma 4.5)</li>
</ul>
<h3 id="bringing-stuff-together-in-theoriesfae.v">Bringing stuff together in <a href="theories/fae.v" class="uri">theories/fae.v</a></h3>
<p>Both directions of theorem 4.1 from the paper are proven there.</p>
<h2 id="credits">Credits</h2>
<p>Lots of code has its origin in the following; https://gitlab.mpi-sws.org/iris/examples/-/tree/master/theories/logrel/F_mu_ref_conc</p>

    </body>
</html>
